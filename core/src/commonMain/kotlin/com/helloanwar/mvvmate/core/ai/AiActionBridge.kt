package com.helloanwar.mvvmate.core.ai

import com.helloanwar.mvvmate.core.*

/**
 * A secure bridge mechanism designed to sit between an Artificial Intelligence (LLM) 
 * and an MVVMate [BaseViewModel].
 * 
 * Provides an interface for the AI to read the current state (with sensitive 
 * information automatically scrubbed) and submit JSON/Text formatted commands
 * which are translated into strictly typed [UiAction]s.
 * 
 * Crucially, submitted actions are passed through an [AiActionPolicy] to ensure 
 * the AI is only allowed to execute safe, non-destructive actions.
 *
 * @param S The [UiState] managed by the ViewModel.
 * @param A The [UiAction] supported by the ViewModel.
 * @param viewModel The ViewModel instances the AI will observe and drive.
 * @param policy The security enforcer that allows or denies specific actions. Defaults to [AllowAllPolicy] (use with caution).
 * @param parser Converts the raw string from the AI into the strongly typed Action.
 * @param redactor Scrubs PII and sensitive data before giving the AI the current state.
 */
class AiActionBridge<S : UiState, A : UiAction>(
    private val viewModel: BaseViewModel<S, A>,
    private val policy: AiActionPolicy<S, A> = AllowAllPolicy(),
    private val parser: AiActionParser<A>,
    private val redactor: PrivacyRedactor = RegexPrivacyRedactor()
) {

    /**
     * Retrieves the current UI State formatted as a string, with sensitive information 
     * scrubbed by the [redactor]. This is safe to include in LLM prompts.
     * 
     * @return A redacted string representation of the ViewModel's state.
     */
    fun getCurrentState(): String {
        return redactor.redact(viewModel.state.value.toString())
    }

    /**
     * Takes raw text/JSON from an LLM, parses it into an Action, validates it against
     * the [AiActionPolicy], and if safe, dispatches it to the ViewModel.
     * 
     * @param rawCommand The raw action command generated by the AI agent.
     * @return A [Result] indicating success or containing the failure (e.g. SecurityException, ParsingException).
     */
    fun dispatch(rawCommand: String): Result<Unit> {
        return try {
            val action = parser.parse(rawCommand)
            
            // Re-evaluate state at exact time of dispatch 
            // (in case state changed between LLM generation and network receipt)
            val currentState = viewModel.state.value
            
            if (policy.isActionAllowed(action, currentState)) {
                viewModel.handleAction(action)
                Result.success(Unit)
            } else {
                val errorMsg = "AI SECURITY VIOLATION: Action ${action::class.simpleName} is denied by policy in state '$currentState'."
                MvvMate.logger.logError(
                    viewModelName = "AiActionBridge", 
                    error = AiSecurityException(errorMsg), 
                    context = "ActionDispatch"
                )
                Result.failure(AiSecurityException(errorMsg))
            }
        } catch (e: Exception) {
            MvvMate.logger.logError(
                viewModelName = "AiActionBridge", 
                error = e, 
                context = "ParsingRawCommand"
            )
            Result.failure(e)
        }
    }
}

/**
 * Exception thrown when the AI attempts to dispatch an action that is forbidden 
 * by the current [AiActionPolicy].
 */
class AiSecurityException(message: String) : Exception(message)
